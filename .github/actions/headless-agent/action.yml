name: "Headless Copilot Agent"
description: >
  Fully configurable hub action that sets up GitHub Copilot CLI, installs
  MCP servers and documentation sources from a config file, and runs an
  agent mission. Use this from any repository as a reusable composite action.

inputs:
  mission:
    description: "The agent mission prompt to execute."
    required: true
  context_files:
    description: "File paths or globs for the agent to consider."
    required: false
    default: "."
  github_token:
    description: "GitHub token with Copilot access for authentication."
    required: true
  model:
    description: "Primary Copilot model to use (e.g. gpt-4o, claude-sonnet-4). Leave blank for default."
    required: false
    default: ""
  fallback_model:
    description: "Fallback model if the primary model hits a quota or availability error."
    required: false
    default: ""
  sources_config:
    description: "Path to a YAML file defining documentation sources (MCP servers, web URLs). If the file doesn't exist, no sources are configured."
    required: false
    default: ".github/sources.yml"

runs:
  using: "composite"
  steps:
    # ── 1. Install Node.js ──────────────────────────────────────────────
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: "20"

    # ── 2. Install gh CLI ───────────────────────────────────────────────
    - name: Install GitHub CLI
      shell: bash
      run: |
        set -euo pipefail
        if ! command -v gh &>/dev/null; then
          echo "::group::Installing GitHub CLI"
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
            | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] \
            https://cli.github.com/packages stable main" \
            | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt-get update -qq && sudo apt-get install -y -qq gh
          echo "::endgroup::"
        fi
        echo "gh version: $(gh --version | head -1)"

    # ── 3. Authenticate gh CLI ──────────────────────────────────────────
    - name: Authenticate GitHub CLI
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
      run: |
        set -euo pipefail
        echo "::group::Authenticating GitHub CLI"
        # GH_TOKEN is already set, so gh is authenticated.
        # We just verify the status.
        gh auth status
        echo "::endgroup::"

    # ── 4. Install gh-copilot extension ─────────────────────────────────
    - name: Install gh-copilot extension
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
      run: |
        set -euo pipefail
        echo "::group::Installing gh-copilot extension"
        
        # Check if gh copilot is already working (could be built-in or pre-installed)
        if gh copilot --help >/dev/null 2>&1; then
          echo "gh copilot is already available."
        else
          echo "Installing github/gh-copilot extension..."
          gh extension install github/gh-copilot --force
        fi
        
        echo "gh-copilot installed/verified successfully"
        echo "::endgroup::"

    # ── 5. Load sources config, install MCP servers & configure ─────────
    - name: Load sources and configure Copilot MCP
      shell: bash
      env:
        SOURCES_CONFIG: ${{ inputs.sources_config }}
      run: |
        set -euo pipefail
        echo "::group::Configuring sources"

        CONFIG_DIR="${HOME}/.config/github-copilot"
        CONFIG_FILE="${CONFIG_DIR}/config.json"
        mkdir -p "${CONFIG_DIR}"

        # Default: no MCP servers, no web sources
        MCP_JSON='{}'
        WEB_SOURCES=""

        if [[ -n "${SOURCES_CONFIG}" && -f "${SOURCES_CONFIG}" ]]; then
          echo "Loading sources from: ${SOURCES_CONFIG}"

          # Use a single Node.js invocation to parse, install, and output config
          PARSE_OUTPUT=$(node << 'PARSE_SCRIPT'
        const fs = require('fs');
        const path = process.env.SOURCES_CONFIG;

        try {
          const content = fs.readFileSync(path, 'utf8');
          const lines = content.split('\n');
          const sources = [];
          let current = null;

          for (const line of lines) {
            const nameMatch = line.match(/^\s*-\s*name:\s*(.+)/);
            if (nameMatch) {
              if (current) sources.push(current);
              current = { name: nameMatch[1].trim() };
              continue;
            }
            if (!current) continue;
            const typeMatch = line.match(/^\s*type:\s*(.+)/);
            const packageMatch = line.match(/^\s*package:\s*["']?([^"']+)["']?/);
            const urlMatch = line.match(/^\s*url:\s*["']?([^"']+)["']?/);
            const enabledMatch = line.match(/^\s*enabled:\s*(.+)/);
            if (typeMatch) current.type = typeMatch[1].trim();
            if (packageMatch) current.package = packageMatch[1].trim();
            if (urlMatch) current.url = urlMatch[1].trim();
            if (enabledMatch) current.enabled = enabledMatch[1].trim() === 'true';
          }
          if (current) sources.push(current);

          // Build MCP servers object from enabled mcp sources
          const mcpServers = {};
          const mcpPackages = [];
          for (const s of sources) {
            if (s.type === 'mcp' && s.enabled && s.package) {
              mcpServers[s.name] = { command: 'npx', args: ['-y', s.package] };
              mcpPackages.push(s.package);
            }
          }

          // Collect enabled web source URLs
          const webUrls = sources
            .filter(s => s.type === 'web' && s.enabled && s.url)
            .map(s => s.url);

          // Output as JSON for the shell to consume
          const output = {
            mcpServers: mcpServers,
            mcpPackages: mcpPackages,
            webSources: webUrls.length > 0
              ? 'Also consult these documentation sources: ' + webUrls.join(', ')
              : ''
          };
          console.log(JSON.stringify(output));
        } catch (e) {
          console.log(JSON.stringify({ mcpServers: {}, mcpPackages: [], webSources: '' }));
        }
        PARSE_SCRIPT
          )

          # Extract values from parsed output
          MCP_JSON=$(echo "${PARSE_OUTPUT}" | node -e "
            const d = JSON.parse(require('fs').readFileSync('/dev/stdin','utf8'));
            console.log(JSON.stringify(d.mcpServers));
          ")

          WEB_SOURCES=$(echo "${PARSE_OUTPUT}" | node -e "
            const d = JSON.parse(require('fs').readFileSync('/dev/stdin','utf8'));
            console.log(d.webSources);
          ")

          # Install MCP packages
          PACKAGES=$(echo "${PARSE_OUTPUT}" | node -e "
            const d = JSON.parse(require('fs').readFileSync('/dev/stdin','utf8'));
            d.mcpPackages.forEach(p => console.log(p));
          ")

          while IFS= read -r pkg; do
            if [[ -n "${pkg}" ]]; then
              echo "Installing MCP package: ${pkg}"
              npm install -g "${pkg}" || echo "::warning::Failed to install ${pkg}"
            fi
          done <<< "${PACKAGES}"

        else
          echo "No sources config provided or file not found — running without MCP servers"
        fi

        # Write the Copilot config (empty mcpServers if none configured)
        node -e "
          const config = { mcpServers: ${MCP_JSON} };
          require('fs').writeFileSync('${CONFIG_FILE}', JSON.stringify(config, null, 2));
        "

        echo "Copilot config written to ${CONFIG_FILE}"
        cat "${CONFIG_FILE}"

        # Export web sources for use in the mission step
        echo "EXTRA_WEB_SOURCES=${WEB_SOURCES}" >> "${GITHUB_ENV}"

        echo "::endgroup::"

    # ── 6. Run the agent mission (with model fallback) ──────────────────
    - name: Execute agent mission
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        AGENT_MISSION: ${{ inputs.mission }}
        CONTEXT_FILES: ${{ inputs.context_files }}
        MODEL: ${{ inputs.model }}
        FALLBACK_MODEL: ${{ inputs.fallback_model }}
      run: |
        set -euo pipefail
        echo "::group::Agent Mission"
        echo "Mission:        ${AGENT_MISSION}"
        echo "Context:        ${CONTEXT_FILES}"
        echo "Model:          ${MODEL:-auto}"
        echo "Fallback Model: ${FALLBACK_MODEL:-none}"
        echo "---"

        # Build the full prompt including web sources
        FULL_MISSION="${AGENT_MISSION} (context files: ${CONTEXT_FILES})"
        if [[ -n "${EXTRA_WEB_SOURCES:-}" ]]; then
          FULL_MISSION="${FULL_MISSION}. ${EXTRA_WEB_SOURCES}"
        fi

        # Build model flags
        MODEL_FLAGS=""
        if [[ -n "${MODEL}" ]]; then
          MODEL_FLAGS="--model ${MODEL}"
        fi

        # ── Attempt with primary model ──
        run_agent() {
          local flags="${1:-}"
          # shellcheck disable=SC2086
          gh copilot \
            --allow-all-tools \
            -p "${FULL_MISSION}" \
            ${flags} \
            2>&1
        }

        if run_agent "${MODEL_FLAGS}"; then
          echo "Agent mission completed successfully."
        else
          EXIT_CODE=$?
          echo "::warning::Primary model failed (exit code: ${EXIT_CODE})"

          if [[ -n "${FALLBACK_MODEL}" ]]; then
            echo "Retrying with fallback model: ${FALLBACK_MODEL}"
            FALLBACK_FLAGS="--model ${FALLBACK_MODEL}"
            if run_agent "${FALLBACK_FLAGS}"; then
              echo "Agent mission completed with fallback model."
            else
              echo "::error::Agent mission failed with both primary and fallback models"
              exit 1
            fi
          else
            echo "::error::Agent mission failed and no fallback model is configured"
            exit 1
          fi
        fi

        echo "::endgroup::"
